<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NO Support Tool â€” Observed Network Environments</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@twemoji/api@latest/dist/twemoji.min.js" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg-primary: #0a0c0f;
            --bg-secondary: #12151a;
            --bg-tertiary: #1a1e25;
            --text-primary: #e8eaed;
            --text-secondary: #9aa0a6;
            --text-tertiary: #5f6368;
            --text-muted: #3c4043;
            --accent: #5c9aa8;
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-default: rgba(255, 255, 255, 0.1);
            --font-display: 'Outfit', sans-serif;
            --font-mono: 'IBM Plex Mono', monospace;
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --grid-gap: 20px;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 14px;
            -webkit-font-smoothing: antialiased;
        }

        body {
            font-family: var(--font-display);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            min-height: 100vh;
        }

        img.emoji {
            height: 1em;
            width: 1em;
            margin: 0 .05em 0 .1em;
            vertical-align: -0.1em;
        }

        .dashboard {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-xl);
        }

        /* Header */
        .header {
            margin-bottom: var(--space-xl);
            padding-bottom: var(--space-lg);
            border-bottom: 1px solid var(--border-subtle);
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 500;
            letter-spacing: -0.02em;
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
        }

        .scope-note {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* Countries Grid */
        .countries-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--grid-gap);
            margin-bottom: var(--space-xl);
        }

        /* Country Card */
        .country-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            overflow: hidden;
            transition: border-color 0.2s ease;
        }

        .country-card:hover {
            border-color: var(--border-default);
        }

        .country-header {
            padding: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--border-subtle);
        }

        .country-flag {
            font-size: 2.5rem;
            line-height: 1;
            cursor: default;
        }

        .country-flag img.emoji {
            height: 2.5rem;
            width: 2.5rem;
        }

        .country-name-tooltip {
            display: none;
            position: absolute;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            padding: var(--space-xs) var(--space-sm);
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
            z-index: 10;
            margin-top: var(--space-xs);
        }

        .country-header:hover .country-name-tooltip {
            display: block;
        }

        .country-body {
            padding: var(--space-lg);
        }

        .runs-count {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: var(--space-md);
        }

        .runs-count strong {
            color: var(--text-primary);
        }

        .failures-section h3 {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-tertiary);
            margin-bottom: var(--space-sm);
            font-weight: 500;
        }

        .failures-list {
            list-style: none;
        }

        .failures-list li {
            font-size: 0.85rem;
            color: var(--text-secondary);
            padding: var(--space-xs) 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .failures-list li::before {
            content: '\2022';
            color: var(--text-muted);
            margin-right: var(--space-sm);
        }

        .failure-name {
            flex: 1;
        }

        .failure-count {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-tertiary);
            margin-left: var(--space-sm);
        }

        .no-failures {
            font-size: 0.85rem;
            color: var(--text-tertiary);
            font-style: italic;
        }

        .insufficient-data {
            font-size: 0.85rem;
            color: var(--text-muted);
            font-style: italic;
            padding: var(--space-sm) 0;
        }

        /* Footer */
        .footer {
            padding-top: var(--space-lg);
            border-top: 1px solid var(--border-subtle);
            text-align: center;
        }

        .disclaimer {
            font-size: 0.75rem;
            color: var(--text-muted);
            line-height: 1.6;
        }

        /* Error Banner */
        .error-banner {
            background: rgba(184, 106, 92, 0.12);
            border: 1px solid rgba(184, 106, 92, 0.5);
            border-radius: 8px;
            padding: var(--space-md) var(--space-lg);
            margin-bottom: var(--space-lg);
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: #b86a5c;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: var(--space-xl);
            color: var(--text-tertiary);
            font-size: 0.9rem;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .dashboard {
                padding: var(--space-md);
            }

            .countries-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <header class="header">
            <h1>Observed Network Environments</h1>
            <p class="scope-note">
                Aggregated network diagnostics by country.<br>
                Countries represent environmental context, not outcomes or attribution.
            </p>
        </header>

        <div id="errorBanner" class="error-banner" hidden></div>

        <div id="countriesGrid" class="countries-grid">
            <!-- Country cards rendered here -->
        </div>

        <footer class="footer">
            <p class="disclaimer">
                This view summarizes observed network failure patterns by country.<br>
                It does not determine cause, responsibility, or required action.
            </p>
        </footer>
    </div>

    <script>
        const BASE_URL = "./data";
        const MIN_RUNS_FOR_PATTERNS = 3;
        const MAX_FAILURES_SHOWN = 3;

        // Country code to name mapping
        const COUNTRY_NAMES = {
            'US': 'United States', 'CA': 'Canada', 'GB': 'United Kingdom',
            'DE': 'Germany', 'FR': 'France', 'AU': 'Australia',
            'NZ': 'New Zealand', 'JP': 'Japan', 'KR': 'South Korea',
            'CN': 'China', 'IN': 'India', 'BR': 'Brazil',
            'MX': 'Mexico', 'ES': 'Spain', 'IT': 'Italy',
            'NL': 'Netherlands', 'BE': 'Belgium', 'CH': 'Switzerland',
            'AT': 'Austria', 'SE': 'Sweden', 'NO': 'Norway',
            'DK': 'Denmark', 'FI': 'Finland', 'IE': 'Ireland',
            'PT': 'Portugal', 'PL': 'Poland', 'CZ': 'Czech Republic',
            'RU': 'Russia', 'ZA': 'South Africa', 'SG': 'Singapore',
            'HK': 'Hong Kong', 'TW': 'Taiwan', 'IL': 'Israel',
            'AE': 'United Arab Emirates', 'SA': 'Saudi Arabia',
            'AR': 'Argentina', 'CL': 'Chile', 'CO': 'Colombia',
            'UNK': 'Unknown'
        };

        // Convert 2-letter country code to flag emoji
        function countryCodeToFlag(code) {
            if (!code || code === 'UNK' || code.length !== 2) {
                return '\u{1F3F3}\u{FE0F}'; // White flag
            }
            const base = 0x1F1E6;
            return String.fromCodePoint(
                ...code.toUpperCase().split('').map(c => base + c.charCodeAt(0) - 65)
            );
        }

        // Get country name from code
        function getCountryName(code) {
            return COUNTRY_NAMES[code] || code || 'Unknown';
        }

        // Fetch all session data
        async function loadAllSessions() {
            const res = await fetch(`${BASE_URL}/index.json`, { cache: "no-store" });
            if (!res.ok) throw new Error("Failed to load data index");

            const index = await res.json();
            const sessions = await Promise.all(
                index.files.map(f =>
                    fetch(`${BASE_URL}/${f}`, { cache: "no-store" })
                        .then(r => r.ok ? r.json() : null)
                        .catch(() => null)
                )
            );

            return sessions.filter(Boolean);
        }

        // Aggregate data by country
        function aggregateByCountry(sessions) {
            const countries = {};

            for (const session of sessions) {
                if (!session.Actions || !Array.isArray(session.Actions)) continue;

                // Get country from first action's evidence
                const firstAction = session.Actions[0];
                const country = firstAction?.Evidence?.CountryCode ||
                               firstAction?.Evidence?.Country ||
                               'UNK';

                if (!countries[country]) {
                    countries[country] = {
                        runs: 0,
                        failures: {}
                    };
                }

                countries[country].runs++;

                // Count failures by Category (operation)
                for (const action of session.Actions) {
                    if (action.Result === 'FAIL' && action.Category) {
                        const category = action.Category;
                        countries[country].failures[category] =
                            (countries[country].failures[category] || 0) + 1;
                    }
                }
            }

            return countries;
        }

        // Sort countries per contract: runs desc, then total failures desc
        function sortCountries(countries) {
            return Object.entries(countries).sort((a, b) => {
                // First: by runs descending
                if (b[1].runs !== a[1].runs) {
                    return b[1].runs - a[1].runs;
                }
                // Second: by total failure count descending
                const totalA = Object.values(a[1].failures).reduce((s, n) => s + n, 0);
                const totalB = Object.values(b[1].failures).reduce((s, n) => s + n, 0);
                return totalB - totalA;
            });
        }

        // Render a single country card
        function renderCountryCard(code, data) {
            const flag = countryCodeToFlag(code);
            const name = getCountryName(code);

            // Get top failures (max 3, sorted by count desc)
            const topFailures = Object.entries(data.failures)
                .sort((a, b) => b[1] - a[1])
                .slice(0, MAX_FAILURES_SHOWN);

            let failuresHtml;

            if (data.runs < MIN_RUNS_FOR_PATTERNS) {
                // Insufficient data
                failuresHtml = `
                    <p class="insufficient-data">
                        Insufficient data to identify recurring patterns
                    </p>
                `;
            } else if (topFailures.length === 0) {
                // No failures observed
                failuresHtml = `
                    <p class="no-failures">
                        No recurring network failures observed
                    </p>
                `;
            } else {
                // Show failure patterns
                failuresHtml = `
                    <ul class="failures-list">
                        ${topFailures.map(([category, count]) => `
                            <li>
                                <span class="failure-name">${category}</span>
                                <span class="failure-count">(${count})</span>
                            </li>
                        `).join('')}
                    </ul>
                `;
            }

            return `
                <div class="country-card">
                    <div class="country-header">
                        <span class="country-flag" title="${name}">${flag}</span>
                        <span class="country-name-tooltip">${name}</span>
                    </div>
                    <div class="country-body">
                        <p class="runs-count">Diagnostics runs: <strong>${data.runs}</strong></p>
                        <div class="failures-section">
                            <h3>Most observed network failures</h3>
                            ${failuresHtml}
                        </div>
                    </div>
                </div>
            `;
        }

        // Render all country cards
        function renderCountries(countries) {
            const container = document.getElementById('countriesGrid');
            const sorted = sortCountries(countries);

            if (sorted.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        No diagnostic data available
                    </div>
                `;
                return;
            }

            container.innerHTML = sorted
                .map(([code, data]) => renderCountryCard(code, data))
                .join('');

            // Parse flag emojis with Twemoji for cross-platform support
            if (typeof twemoji !== 'undefined') {
                twemoji.parse(container, {
                    folder: 'svg',
                    ext: '.svg'
                });
            }
        }

        // Show error
        function showError(message) {
            const banner = document.getElementById('errorBanner');
            banner.textContent = `ERROR: ${message}`;
            banner.hidden = false;
        }

        // Main
        async function main() {
            try {
                const sessions = await loadAllSessions();
                const countries = aggregateByCountry(sessions);
                renderCountries(countries);
            } catch (err) {
                showError(err.message);
            }
        }

        main();
    </script>
</body>
</html>
